// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems.arm;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

import frc.robot.RobotMap;
import frc.robot.commands.arm.DefaultArm;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Arm extends Subsystem {


    //arm encoder positions
    public static final int ARM_POSITION_ZERO = 0;
    public static final int ARM_POSITION_PICKUP_CARGO = 6000;
    public static final int ARM_POSITION_SCORING_CARGO = 0;
    public static final int ARM_POSITION_CLIMB = 6000;


    private TalonSRX armMotor;
    private TalonSRX intakeMotor;
    private AnalogInput absoluteEncoder;
    private DigitalInput forwardLimitSwitch;
    private DigitalInput backwardLimitSwitch;

    //softlimits
    private final int ARM_TALON_REVERSE_SOFT_LIMIT = 4615;
    private final int ARM_TALON_FORWARD_SOFT_LIMIT = 6000;
        //upper  4.3652
        //lower  0.91308
    
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public Arm() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        //talonSRX4 = new WPI_TalonSRX(4);
        // talonSRX4.setInverted(true);
        forwardLimitSwitch = new DigitalInput(RobotMap.FORWARD_ARM_LIMIT_SWITCH); 
        // backwardLimitSwitch = new DigitalInput(RobotMap.BACKWARD_ARM_LIMIT_SWITCH);

        armMotor = new TalonSRX(RobotMap.ARM_TALON);
        armMotor.configFactoryDefault();
        armMotor.setInverted(true);

        absoluteEncoder = new AnalogInput(RobotMap.ARM_ABSOLUTE_ENCODER);
        addChild("AnalogInput0",absoluteEncoder);
        
        armMotor.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder,0,0);
        armMotor.configForwardSoftLimitThreshold(ARM_TALON_FORWARD_SOFT_LIMIT);
        armMotor.configReverseSoftLimitThreshold(ARM_TALON_REVERSE_SOFT_LIMIT);
        // armMotor.configForwardSoftLimitEnable(true);
        // armMotor.configReverseSoftLimitEnable(true);
        
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DefaultArm());

    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
    }

    public void setMotor(double speed){
        double encoderValue = getRelativeEncoder();

        /* if (speed > 0 ){
            if (encoderValue >= ARM_UPPER_SOFT_LIMIT){
                speed = 0;
                // System.out.println("stopped by upper limit");
            }
        } else if (speed < 0 ){
            if (encoderValue <= ARM_LOWER_SOFT_LIMIT){
            speed = 0;
            //    System.out.println("stopped by lower limit");
        }*/


        // double coefficient = NetworkTableInstance.getDefault().getTable("/Shuffleboard").getSubTable("Arm Testing")
        // .getEntry("coefficient on arm").getDouble(0.0);
        double coefficient = SmartDashboard.getNumber("coefficient on arm",0.5);


        //SmartDashboard.putNumber("speed", speed);
        // if(forwardLimitSwitch.get() && speed>0){//if it is too far forward
        //     armMotor.set(ControlMode.PercentOutput, 0); 
        // } 
        // else if(backwardLimitSwitch.get() && speed<0){//if it is too far backward
        //     armMotor.set(ControlMode.PercentOutput, 0);
        // } else{
            armMotor.set(ControlMode.PercentOutput, speed * coefficient);
        // }
    }
    
        

    public double getRelativeEncoder(){
        return armMotor.getSelectedSensorPosition(0);        
    }
    public double getAbsoluteEncoder(){
        return absoluteEncoder.getAverageVoltage();
    } 
        
}

