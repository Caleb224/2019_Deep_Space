// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems.arm;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

import frc.robot.RobotMap;
import frc.robot.commands.arm.DefaultArm;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Arm extends Subsystem {

    // arm encoder positions
    public static final int ARM_POSITION_ZERO = 0;
    public static final int ARM_POSITION_PICKUP_CARGO = 5000;
    public static final int ARM_POSITION_SCORING_CARGO = 0;
    public static final int ARM_POSITION_CLIMB = 6000;

    public static final double kF = 1.5;
    private static double kP = 0.25;
    private static double kI = 0;
    private static double kD = 25;

    // /*
    // * kF = full forward value * duty-cycle (%) / runtime calculated target
    // (ticks,
    // * velocity units/100 ms) = 1023 * 100% / 1525 =
    // *
    // * ARM UP
    // * kF = 1023 * 0.5 / (250.5) = 2.0419161676646706586826347305389
    // *
    // * ARM DOWN kF =
    // *
    // */

    private static int kTimeoutMs = 5;

    private TalonSRX armMotor;
    private TalonSRX intakeMotor;
    private AnalogInput absoluteEncoder;
    private DigitalInput forwardLimitSwitch;
    private DigitalInput backwardLimitSwitch;

    // softlimits
    private final int ARM_TALON_REVERSE_SOFT_LIMIT = 4615;
    private final int ARM_TALON_FORWARD_SOFT_LIMIT = 6000;
    // upper 4.3652
    // lower 0.91308

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public Arm() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // talonSRX4 = new WPI_TalonSRX(4);
        // talonSRX4.setInverted(true);
        forwardLimitSwitch = new DigitalInput(RobotMap.FORWARD_ARM_LIMIT_SWITCH);
        // backwardLimitSwitch = new DigitalInput(RobotMap.BACKWARD_ARM_LIMIT_SWITCH);

        armMotor = new TalonSRX(RobotMap.ARM_TALON);
        armMotor.configFactoryDefault();
        armMotor.setInverted(true);

        absoluteEncoder = new AnalogInput(RobotMap.ARM_ABSOLUTE_ENCODER);
        addChild("AnalogInput0", absoluteEncoder);

        armMotor.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, 0);
        armMotor.configForwardSoftLimitThreshold(ARM_TALON_FORWARD_SOFT_LIMIT);
        armMotor.configReverseSoftLimitThreshold(ARM_TALON_REVERSE_SOFT_LIMIT);
        // armMotor.configForwardSoftLimitEnable(true);
        // armMotor.configReverseSoftLimitEnable(true);

        armMotor.configMotionCruiseVelocity(251, kTimeoutMs); // determined with PhoenixTuner, for motor output 99.22%
        armMotor.configMotionAcceleration(1004, kTimeoutMs); // cruise velocity / 2, so it will take 2 seconds to reach

        armMotor.config_kP(0, kP, 0); // find values
        armMotor.config_kI(0, kI, 0); // find values
        armMotor.config_kD(0, kD, 0); // find values
        armMotor.config_kF(0, kF, 0); // find values

    }

    @Override
    public void initDefaultCommand() {
        setDefaultCommand(new DefaultArm());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
    }

    public void setMotor(double speed) {
        double encoderValue = getRelativeEncoder();
        // double cap = SmartDashboard.getNumber("arm speed cap", 1);

        /*
         * if (speed > 0 ){ if (encoderValue >= ARM_UPPER_SOFT_LIMIT){ speed = 0; //
         * System.out.println("stopped by upper limit"); } } else if (speed < 0 ){ if
         * (encoderValue <= ARM_LOWER_SOFT_LIMIT){ speed = 0; //
         * System.out.println("stopped by lower limit"); }
         */

        // double coefficient =
        // NetworkTableInstance.getDefault().getTable("/Shuffleboard").getSubTable("Arm
        // Testing")
        // .getEntry("coefficient on arm").getDouble(0.0);

        // SmartDashboard.putNumber("speed", speed);
        // if(forwardLimitSwitch.get() && speed>0){//if it is too far forward
        // armMotor.set(ControlMode.PercentOutput, 0);
        // }
        // else if(backwardLimitSwitch.get() && speed<0){//if it is too far backward
        // armMotor.set(ControlMode.PercentOutput, 0);
        // } else{

        if (getArmLimit()) {
            armMotor.setSelectedSensorPosition(0);
        }

        // if (Math.abs(speed) > cap) {
        //     if (speed < 0) {
        //         speed = -cap;
        //     } else {
        //         speed = cap;
        //     }
        // }
        armMotor.set(ControlMode.PercentOutput, speed);

    }

    public boolean getArmLimit() {
        return !forwardLimitSwitch.get();
    }

    public void configStart_MM(double targetPos) {
        // if (targetPos > getRelativeEncoder()) {
            // forward slot
            armMotor.selectProfileSlot(0, 0);
            // armMotor.config_kP(0, kP, 0); // find values
            // armMotor.config_kI(0, kI, 0); // find values
            // armMotor.config_kD(0, kD, 0); // find values
            // armMotor.config_kF(0, kF, 0); // find values
            // armMotor.config_kF(0, 1, 0); // find values - auxiliary feed forward
        // } else {
        //     // backward slot
        //     armMotor.selectProfileSlot(1, 0);
        //     // armMotor.config_kP(1, kP, 0); // find values
        //     // armMotor.config_kI(1, kI, 0); // find values
        //     // armMotor.config_kD(1, kD, 0); // find values
        //     // armMotor.config_kF(1, kF, 0); // find values
        //     // armMotor.config_kF(1, 1, 0); // find values - auxiliary feed forward
        // }
    }

    public void move_MM(double targetPos) {

        armMotor.configAllowableClosedloopError(0, 10, kTimeoutMs);

        armMotor.set(ControlMode.MotionMagic, targetPos);

    }

    public boolean onTarget_MM(double targetPos) {
        double tolerance = 10;

        double currentPos = armMotor.getSelectedSensorPosition();

        return Math.abs(currentPos - targetPos) < tolerance;

    }

    public double getRelativeEncoder() {
        return armMotor.getSelectedSensorPosition(0);
    }

    public double getAbsoluteEncoder() {
        return absoluteEncoder.getAverageVoltage();
    }

}
